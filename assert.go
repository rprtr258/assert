package assert

import (
	"cmp"
	"fmt"
	"iter"
	"math"
	"path/filepath"
	"reflect"
	"regexp"
	"runtime"
	"slices"
	"strconv"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/rprtr258/assert/internal/fun"
	"github.com/rprtr258/assert/internal/pp"
	"github.com/rprtr258/assert/internal/q"
	"github.com/rprtr258/assert/internal/scuf"
)

const _shortLimit = 100

var (
	_fgExpected = scuf.FgRGB(0x96, 0xf7, 0x59) //nolint:mnd
	_fgActual   = scuf.FgRGB(0xff, 0x40, 0x53) //nolint:mnd
)

func mapJoin[T any](seq iter.Seq[T], toString func(T) string, sep string) string {
	var sb strings.Builder
	for v := range seq {
		if sb.Len() > 0 {
			sb.WriteString(sep)
		}
		sb.WriteString(toString(v))
	}
	return sb.String()
}

// isTest tells whether name looks like a test or benchmark, according to prefix.
// It is a Test (say) if there is a character after Test that is not a lower-case letter.
// We don't want TesticularCancer.
func isTest(name string) bool {
	for _, prefix := range []string{"Test", "Benchmark", "Example"} {
		if !strings.HasPrefix(name, prefix) {
			continue
		}

		if len(name) == len(prefix) { // "Test" is ok
			return true
		}

		r, _ := utf8.DecodeRuneInString(name[len(prefix):])
		if unicode.IsUpper(r) {
			return true
		}
	}
	return false
}

// caller is necessary because the assert functions use the testing object
// internally, causing it to print the file:line of the assert method, rather
// than where the problem actually occurred in calling code.
type caller struct {
	file     string
	line     int
	funcName string
}

// callerInfo returns an array of strings containing the file and line number
// of each stack frame leading from the current test to the assert call that
// failed.
func callerInfo() iter.Seq[caller] {
	return func(yield func(caller) bool) {
		for i := 0; ; i++ {
			pc, file, line, ok := runtime.Caller(i)
			if !ok {
				// The breaks below failed to terminate the loop, and we ran off the
				// end of the call stack.
				break
			}

			// This is a huge edge case, but it will panic if this is the case, see #180
			if file == "<autogenerated>" {
				break
			}

			f := runtime.FuncForPC(pc)
			if f == nil {
				break
			}
			name := f.Name()

			// testing.tRunner is the standard library function that calls
			// tests. Subtests are called directly by tRunner, without going through
			// the Test/Benchmark/Example function that contains the t.Run calls, so
			// with subtests we should break when we hit tRunner, without adding it
			// to the list of callers.
			if name == "testing.tRunner" {
				break
			}

			parts := strings.Split(file, "/")
			file = parts[len(parts)-1]
			if len(parts) > 1 {
				dir := parts[len(parts)-2]
				if dir != "assert" && dir != "mock" && dir != "require" || file == "mock_test.go" {
					path, _ := filepath.Abs(file)
					if !yield(caller{path, line, name}) {
						return
					}
				}
			}

			// Drop the package
			segments := strings.Split(name, ".")
			name = segments[len(segments)-1]
			if isTest(name) {
				break
			}
		}
	}
}

type labeledContent struct {
	label, content string
}

func Equal[E any](t T, expected, actual E) {
	t.Helper()
	if reflect.DeepEqual(expected, actual) {
		return
	}

	argNames := q.Q("assert", "Equal")
	expectedName := cmp.Or(argNames[1], "Expected")
	actualName := cmp.Or(argNames[2], "Actual")

	fail(t, []labeledContent{
		{
			scuf.String("Not equal", scuf.FgHiRed),
			mapJoin(diff(expected, actual), func(line diffLine) string {
				if line.expected == nil { // TODO: remove
					return line.selector
				}

				shorten := func(name, s string) string {
					// TODO: do string width if this code is kept
					short := strings.NewReplacer(
						"{\n    ", "{",
						",\n    ", ", ",
						",\n", "",
					).Replace(s)
					if len(name)+len(s) < _shortLimit {
						return short
					}

					return s
				}

				expectedStr := shorten(expectedName, pp.Sprint(line.expected))
				actualStr := shorten(actualName, pp.Sprint(line.actual))

				if strings.ContainsRune(expectedStr, '\n') || strings.ContainsRune(actualStr, '\n') {
					return fun.Ternary(line.comment != "", line.comment+":\n", "") +
						scuf.String(expectedName+line.selector, _fgExpected) + " = " + expectedStr + "\n" +
						scuf.String(actualName+line.selector, _fgActual) + " = " + actualStr
				}

				comment := fun.Ternary(line.comment != "", ", "+line.comment, "")
				return scuf.String(expectedName+line.selector, _fgExpected) + " != " + scuf.String(actualName+line.selector, _fgActual) + comment + ":\n" +
					"\t" + expectedStr + " !=\n" +
					"\t" + actualStr
			}, "\n\n"),
		},
	})
}

func fail(t T, lines []labeledContent) {
	t.Helper()

	stacktraceLabeledContent := labeledContent{
		scuf.String("Stacktrace", scuf.ModFaint),
		mapJoin(callerInfo(), func(v caller) string {
			j := strings.LastIndexByte(v.funcName, '/')
			shortFuncName := v.funcName[j+1:]
			return scuf.String(v.file, scuf.FgHiWhite) +
				":" +
				scuf.String(strconv.Itoa(v.line), scuf.FgGreen) +
				"\t" +
				scuf.String(shortFuncName, scuf.FgBlue)
		}, "\n"),
	}

	lines = append([]labeledContent{stacktraceLabeledContent}, lines...)
	t.Error("\n" + mapJoin(slices.Values(lines), func(v labeledContent) string {
		return v.label + ":\n    " +
			strings.ReplaceAll(v.content, "\n", "\n    ")
	}, "\n"))
}

func NotEqual[E any](t T, expected, actual E) {
	t.Helper()
	if !reflect.DeepEqual(expected, actual) {
		return
	}

	argNames := q.Q("assert", "NotEqual")
	expectedName := cmp.Or(argNames[1], "Expected")
	actualName := cmp.Or(argNames[2], "Actual")

	fail(t, []labeledContent{
		{
			scuf.String("Equal", scuf.FgHiRed),
			fmt.Sprintf(
				"%s and %s are equal, asserted not to, value is:\n\t%s",
				scuf.String(expectedName, _fgExpected),
				scuf.String(actualName, _fgActual),
				strings.ReplaceAll(pp.Sprint(expected), "\n", "\n\t"),
			),
		},
	})
}

func Zero[E any](t T, actual E) {
	t.Helper()
	var zero E
	if reflect.DeepEqual(zero, actual) {
		return
	}

	argNames := q.Q("assert", "Zero")
	expectedName := "Zero"
	actualName := cmp.Or(argNames[1], "Actual")

	fail(t, []labeledContent{
		{
			scuf.String("Not equal", scuf.FgHiRed),
			mapJoin(diff(zero, actual), func(line diffLine) string {
				if line.expected == nil { // TODO: remove
					return line.selector
				}

				shorten := func(name, s string) string {
					// TODO: do string width if this code is kept
					short := strings.NewReplacer(
						"{\n    ", "{",
						",\n    ", ", ",
						",\n", "",
					).Replace(s)
					if len(name)+len(s) < _shortLimit {
						return short
					}

					return s
				}

				expectedStr := shorten(expectedName, pp.Sprint(line.expected))
				actualStr := shorten(actualName, pp.Sprint(line.actual))

				if strings.ContainsRune(expectedStr, '\n') || strings.ContainsRune(actualStr, '\n') {
					return fun.Ternary(line.comment == "", "", line.comment+":") + "\n" +
						scuf.String(expectedName+line.selector, _fgExpected) + " = " + expectedStr + "\n" +
						scuf.String(actualName+line.selector, _fgActual) + " = " + actualStr
				}

				comment := fun.Ternary(line.comment == "", "", ", "+line.comment)
				return scuf.String(expectedName+line.selector, _fgExpected) + " != " + scuf.String(actualName+line.selector, _fgActual) + comment + ":\n" +
					"\t" + expectedStr + " != " + actualStr
			}, "\n\n"),
		},
	})
}

func NotZero[E any](t T, actual E) {
	t.Helper()
	var zero E
	if !reflect.DeepEqual(zero, actual) {
		return
	}

	argNames := q.Q("assert", "NotZero")
	actualName := cmp.Or(argNames[1], "Actual")

	fail(t, []labeledContent{
		{
			scuf.String("Value is zero", scuf.FgHiRed),
			scuf.String(actualName, _fgActual) + " is zero, asserted not to",
		},
	})
}

func True(t T, condition bool) {
	t.Helper()
	if condition {
		return
	}

	argNames := q.Q("assert", "True")
	conditionName := cmp.Or(argNames[1], "Condition")

	fail(t, []labeledContent{
		{
			"Condition is false",
			conditionName + scuf.String(" is false", scuf.FgHiRed),
		},
	})
}

func False(t T, condition bool) {
	t.Helper()
	if !condition {
		return
	}

	argNames := q.Q("assert", "False")
	conditionName := cmp.Or(argNames[1], "Condition")

	fail(t, []labeledContent{
		{
			"Condition is true",
			conditionName + scuf.String(" is true", scuf.FgHiRed),
		},
	})
}

func NoError(t T, err error) {
	t.Helper()
	if err == nil {
		return
	}

	argNames := q.Q("assert", "NoError")
	errorName := cmp.Or(argNames[1], "Error")

	fail(t, []labeledContent{
		{
			"Unexpected error",
			errorName + " is " + pp.Sprint(err.Error()),
		},
	})
}

func SliceContains[E comparable](t T, slice []E, item E) {
	t.Helper()
	if slices.Contains(slice, item) {
		return
	}

	argNames := q.Q("assert", "SliceContains")
	sliceName := cmp.Or(argNames[1], "Slice")
	itemName := cmp.Or(argNames[2], "Item")

	fail(t, []labeledContent{
		{
			label: "Slice does not contain item",
			content: sliceName + ": " + pp.Sprint(slice) + "\n" +
				itemName + ": " + pp.Sprint(item),
		},
	})
}

func MapContainsValue[K, V comparable](t T, m map[K]V, item V) {
	t.Helper()
	for _, v := range m {
		if v == item {
			return
		}
	}

	argNames := q.Q("assert", "MapContainsValue")
	mapName := cmp.Or(argNames[1], "Map")
	itemName := cmp.Or(argNames[2], "Value")

	fail(t, []labeledContent{
		{
			label: "Map does not contain value",
			content: mapName + ": " + pp.Sprint(m) + "\n" +
				itemName + ": " + pp.Sprint(item),
		},
	})
}

func MapContainsKey[K comparable, V any](t T, m map[K]V, item K) {
	t.Helper()
	for k := range m {
		if k == item {
			return
		}
	}

	argNames := q.Q("assert", "MapContainsKey")
	mapName := cmp.Or(argNames[1], "Map")
	itemName := cmp.Or(argNames[2], "Key")

	fail(t, []labeledContent{
		{
			label: "Map does not contain key",
			content: mapName + ": " + pp.Sprint(m) + "\n" +
				itemName + ": " + pp.Sprint(item),
		},
	})
}

func Substring(t T, text, substr string) {
	t.Helper()
	if strings.Contains(text, substr) {
		return
	}

	argNames := q.Q("assert", "Substring")
	textName := cmp.Or(argNames[1], "Text")
	needleName := cmp.Or(argNames[2], "Substring")

	fail(t, []labeledContent{
		{
			label: "String does not contain substring",
			content: textName + ": " + pp.Sprint(text) + "\n" +
				needleName + ": " + pp.Sprint(substr),
		},
	})
}

func Regexp(t T, re, text string) {
	t.Helper()
	True(t, regexp.MustCompile(re).MatchString(text))
}

func EqualError(t T, expectedErrText string, err error) {
	t.Helper()
	Equal(t, expectedErrText, err.Error())
}

func SliceLen[E any](t T, lenn int, slice []E) {
	t.Helper()
	Equal(t, lenn, len(slice))
}

func MapLen[K comparable, V any](t T, lenn int, m map[K]V) {
	t.Helper()
	Equal(t, lenn, len(m))
}

type WaitUntilConfig struct {
	Timeout, CheckPeriod time.Duration
	Attempts             int
}

func AssertWaitUntil(t T, f func() bool, cfg WaitUntilConfig) {
	t.Helper()

	cfg.Attempts = cmp.Or(cfg.Attempts, math.MaxInt)

	timeouter := time.NewTimer(cfg.Timeout)
	defer timeouter.Stop()
	ticker := time.NewTicker(cfg.CheckPeriod)
	defer ticker.Stop()
	for range cfg.Attempts {
		if f() {
			return
		}

		select {
		case <-timeouter.C:
			if f() {
				return
			}

			t.Fatal("timeout")
		case <-ticker.C:
		}
	}
}
